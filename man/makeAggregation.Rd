% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Aggregation.R
\name{makeAggregation}
\alias{makeAggregation}
\title{Specify your own aggregation of measures.}
\usage{
makeAggregation(id, name = id, properties, fun)
}
\arguments{
\item{id}{(`character(1)`)\cr
Name of the aggregation method (preferably the same name as the generated function).}

\item{name}{(`character(1)`)\cr
Long name of the aggregation method. Default is `id`.}

\item{properties}{([character])\cr
Set of aggregation properties.
\describe{
  \item{req.train}{Are prediction or train sets required to calculate the aggregation?}
  \item{req.test}{Are prediction or test sets required to calculate the aggregation?}
}}

\item{fun}{(`function(task, perf.test, perf.train, measure, group, pred)`)\cr
Calculates the aggregated performance. In most cases you will only need the performances
`perf.test` and optionally `perf.train` on the test and training data sets.
\describe{
  \item{`task` ([Task])}{The task.}
  \item{`perf.test` ([numeric])}{
    [performance] results on the test data sets.}
  \item{`perf.train` ([numeric])}{
    [performance] results on the training data sets.}
  \item{`measure` ([Measure])}{
    Performance measure.}
  \item{`group` ([factor])}{
    Grouping of resampling iterations. This encodes whether specific iterations
    'belong together' (e.g. repeated CV).}
  \item{`pred` ([Prediction])}{
    Prediction object.}
}}
}
\value{
([Aggregation]).
}
\description{
This is an advanced feature of mlr. It gives access to some
inner workings so the result might not be compatible with everything!
}
\examples{
# computes the interquartile range on all performance values
test.iqr = makeAggregation(id = "test.iqr", name = "Test set interquartile range",
  properties = "req.test",
  fun = function (task, perf.test, perf.train, measure, group, pred) IQR(perf.test))
}
\seealso{
[aggregations], [setAggregation]
}

