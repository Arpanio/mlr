<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Data Preprocessing • mlr</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../jquery.sticky-kit.min.js"></script><script src="../../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../../index.html">mlr</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../articles/mlr.html">Get Started</a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Basics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/task.html">Tasks</a>
    </li>
    <li>
      <a href="../../articles/tutorial/learners.html">Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/predict.html">Predict</a>
    </li>
    <li>
      <a href="../../articles/tutorial/performance.html">Performance</a>
    </li>
    <li>
      <a href="../../articles/tutorial/resample.html">Resampling</a>
    </li>
    <li>
      <a href="../../articles/tutorial/tune.html">Tuning</a>
    </li>
    <li>
      <a href="../../articles/tutorial/benchmark_experiments.html">Benchmark Experiments</a>
    </li>
    <li>
      <a href="../../articles/tutorial/parallelization.html">Parallelization</a>
    </li>
    <li>
      <a href="../../articles/tutorial/visualization.html">Visualization</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Advanced
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/configuring.html">Configuration</a>
    </li>
    <li>
      <a href="../../articles/tutorial/wrapper.html">Wrapped Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/preproc.html">Preprocessing</a>
    </li>
    <li>
      <a href="../../articles/tutorial/impute.html">Imputation</a>
    </li>
    <li>
      <a href="../../articles/tutorial/bagging.html">Generic Bagging</a>
    </li>
    <li>
      <a href="../../articles/tutorial/advanced_tune.html">Advanced Tuning</a>
    </li>
    <li>
      <a href="../../articles/tutorial/feature_selection.html">Feature Selection</a>
    </li>
    <li>
      <a href="../../articles/tutorial/nested_resampling.html">Nested Resampling</a>
    </li>
    <li>
      <a href="../../articles/tutorial/cost_sensitive_classif.html">Cost-Sensitive Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial/imbalanced_classification_problems.html">Imbalanced Classification Problems</a>
    </li>
    <li>
      <a href="../../articles/tutorial/roc_analysis.html">ROC Analysis and Performance Curves</a>
    </li>
    <li>
      <a href="../../articles/tutorial/multilabel.html">Multilabel Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial/learning_curve_analysis.html">Learning Curve Analysis</a>
    </li>
    <li>
      <a href="../../articles/tutorial/partial_dependence.html">Partial Dependence Plots</a>
    </li>
    <li>
      <a href="../../articles/tutorial/classifier_calibration.html">Classifier Calibration</a>
    </li>
    <li>
      <a href="../../articles/tutorial/hyperparameter_tuning_effects.html">Hyperparameter Tuning Effects</a>
    </li>
    <li>
      <a href="../../articles/tutorial/out_of_bag_predictions.html">Out-of-Bag Predictions</a>
    </li>
    <li>
      <a href="../../articles/tutorial/handling_of_spatial_data.html">Handling of Spatial Data</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Extend
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/custom_learners.html">Create Custom Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/custom_measures.html">Create Custom Measures</a>
    </li>
    <li>
      <a href="../../articles/tutorial/create_imputation.html">Create Imputation Methods</a>
    </li>
    <li>
      <a href="../../articles/tutorial/create_filter.html">Create Custom Filters</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Appendix
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/example_tasks.html">Example Tasks</a>
    </li>
    <li>
      <a href="../../articles/tutorial/integrated_learners.html">Integrated Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/implemented_measures.html">Implemented Measures</a>
    </li>
    <li>
      <a href="../../articles/tutorial/filter_methods.html">Integrated Filter Methods</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mlr-org/mlr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<form class="navbar-form" role="search" method="GET" action="../../search.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" id="search" name="search">
</div>
        <button type="submit" class="btn btn-default">
          <i class="glyphicon glyphicon-search"></i>
        </button>
      </form>
    </div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Data Preprocessing</h1>
            
          </div>

    
    
<div class="contents">
<p>Data preprocessing refers to any transformation of the data done before applying a learning algorithm. This comprises for example finding and resolving inconsistencies, imputation of missing values, identifying, removing or replacing outliers, discretizing numerical data or generating numerical dummy variables for categorical data, any kind of transformation like standardization of predictors or Box-Cox, dimensionality reduction and feature extraction and/or selection.</p>
<p>[%mlr] offers several options for data preprocessing. Some of the following simple methods to change a [&amp;Task] (or <a href="&amp;base::data.frame">data.frame</a>) were already mentioned on the page about <a href="task.md">learning tasks</a>:</p>
<ul>
<li>
<li>
<li>
<li>new, larger classes.</li>
<li>
<li>standardization or scaling to a certain range.</li>
<li>
<li>[&amp;subsetTask]: Remove observations and/or features from a [&amp;Task].</li>
</ul>
<p>Moreover, there are tutorial pages devoted to</p>
<ul>
<li>
<a href="feature_selection.md">Feature selection</a> and</li>
<li>
<a href="impute.md">Imputation of missing values</a>.</li>
</ul>
<div id="fusing-learners-with-preprocessing" class="section level2">
<h2 class="hasAnchor">
<a href="#fusing-learners-with-preprocessing" class="anchor"></a>Fusing learners with preprocessing</h2>
<p>[%mlr]’s wrapper functionality permits to combine learners with preprocessing steps. This means that the preprocessing “belongs” to the learner and is done any time the learner is trained or predictions are made.</p>
<p>This is, on the one hand, very practical. You don’t need to change any data or learning [&amp;Task]s and it’s quite easy to combine different learners with different preprocessing steps.</p>
<p>On the other hand this helps to avoid a common mistake in evaluating the performance of a learner with preprocessing: Preprocessing is often seen as completely independent of the later applied learning algorithms. When estimating the performance of the a learner, e.g., by cross-validation all preprocessing is done beforehand on the full data set and only training/predicting the learner is done on the train/test sets. Depending on what exactly is done as preprocessing this can lead to overoptimistic results. For example if imputation by the mean is done on the whole data set before evaluating the learner performance you are using information from the test data during training, which can cause overoptimistic performance results.</p>
<p>To clarify things one should distinguish between <em>data-dependent</em> and <em>data-independent</em> preprocessing steps: Data-dependent steps in some way learn from the data and give different results when applied to different data sets. Data-independent steps always lead to the same results. Clearly, correcting errors in the data or removing data columns like Ids that should not be used for learning, is data-independent. Imputation of missing values by the mean, as mentioned above, is data-dependent. Imputation by a fixed constant, however, is not.</p>
<p>To get a honest estimate of learner performance combined with preprocessing, all data-dependent preprocessing steps must be included in the resampling. This is automatically done when fusing a learner with preprocessing.</p>
<p>To this end [%mlr] provides two <a href="wrapper.md">wrappers</a>:</p>
<ul>
<li>[&amp;makePreprocWrapperCaret] is an interface to all preprocessing options offered by [%caret]’s <a href="&amp;caret::preProcess">preProcess</a> function.</li>
<li>[&amp;makePreprocWrapper] permits to write your own custom preprocessing methods by defining the actions to be taken before training and before prediction.</li>
</ul>
<p>As mentioned above the specified preprocessing steps then “belong” to the wrapped <a href="&amp;makeLearner">Learner</a>. In contrast to the preprocessing options listed above like <a href="Normalize%20features%20by%20different%20methods,%20e.g.,">&amp;normalizeFeatures</a></p>
<ul>
<li>the [&amp;Task] itself remains unchanged,</li>
<li>the preprocessing is not done globally, i.e., for the whole data set, but for every pair of training/test data sets in, e.g., resampling,</li>
<li>any parameters controlling the preprocessing as, e.g., the percentage of outliers to be removed can be <a href="tune.md">tuned</a> together with the base learner parameters.</li>
</ul>
<p>We start with some examples for [&amp;makePreprocWrapperCaret].</p>
</div>
<div id="preprocessing-with-makepreprocwrappercaret" class="section level2">
<h2 class="hasAnchor">
<a href="#preprocessing-with-makepreprocwrappercaret" class="anchor"></a>Preprocessing with makePreprocWrapperCaret</h2>
<p>[&amp;makePreprocWrapperCaret] is an interface to [%caret]’s <a href="&amp;caret::preProcess">preProcess</a> function that provides many different options like imputation of missing values, data transformations as scaling the features to a certain range or Box-Cox and dimensionality reduction via Independent or Principal Component Analysis. For all possible options see the help page of function <a href="&amp;caret::preProcess">preProcess</a>.</p>
<p>Note that the usage of [&amp;makePreprocWrapperCaret] is slightly different than that of <a href="&amp;caret::preProcess">preProcess</a>.</p>
<ul>
<li>[&amp;makePreprocWrapperCaret] takes (almost) the same formal arguments as <a href="&amp;caret:preProcess">preProcess</a>, but their names are prefixed by <code>ppc.</code>.</li>
<li>The only exception: [&amp;makePreprocWrapperCaret] does not have a <code>method</code> argument. Instead all preprocessing options that would be passed to <a href="&amp;caret::preProcess">preProcess</a>’s <code>method</code> argument are given as individual logical parameters to [&amp;makePreprocWrapperCaret].</li>
</ul>
<p>For example the following call to <a href="&amp;caret::preProcess">preProcess</a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">preProcess</span>(x, <span class="dt">method =</span> <span class="kw">c</span>(<span class="st">"knnImpute"</span>, <span class="st">"pca"</span>), <span class="dt">pcaComp =</span> <span class="dv">10</span>)</code></pre></div>
<p>with <code>x</code> being a <a href="&amp;base::matrix">matrix</a> or <a href="&amp;base::data.frame">data.frame</a> would thus translate into</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/makePreprocWrapperCaret.html">makePreprocWrapperCaret</a></span>(learner, <span class="dt">ppc.knnImpute =</span> <span class="ot">TRUE</span>, <span class="dt">ppc.pca =</span> <span class="ot">TRUE</span>, <span class="dt">ppc.pcaComp =</span> <span class="dv">10</span>)</code></pre></div>
<p>where <code>learner</code> is a [%mlr] [Learner](&amp;makeLearner) or the name of a learner class like <code>"classif.lda"</code>.</p>
<p>If you enable multiple preprocessing options (like knn imputation and principal component analysis above) these are executed in a certain order detailed on the help page of function <a href="&amp;caret::preProcess">preProcess</a>.</p>
<p>In the following we show an example where principal components analysis (PCA) is used for dimensionality reduction. This should never be applied blindly, but can be beneficial with learners that get problems with high dimensionality or those that can profit from rotating the data.</p>
<p>We consider the [&amp;sonar.task], which poses a binary classification problem with 208 observations and 60 features.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sonar.task</code></pre></div>
<pre><code>## Supervised task: Sonar-example
## Type: classif
## Target: Class
## Observations: 208
## Features:
##    numerics     factors     ordered functionals 
##          60           0           0           0 
## Missings: FALSE
## Has weights: FALSE
## Has blocking: FALSE
## Is spatial: FALSE
## Classes: 2
##   M   R 
## 111  97 
## Positive class: M</code></pre>
<p>Below we fuse <a href="&amp;MASS::qda">quadratic discriminant analysis</a> from package [%MASS] with a principal components preprocessing step. The threshold is set to 0.9, i.e., the principal components necessary to explain a cumulative percentage of 90% of the total variance are kept. The data are automatically standardized prior to PCA.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makePreprocWrapperCaret.html">makePreprocWrapperCaret</a></span>(<span class="st">"classif.qda"</span>, <span class="dt">ppc.pca =</span> <span class="ot">TRUE</span>, <span class="dt">ppc.thresh =</span> <span class="fl">0.9</span>)
lrn</code></pre></div>
<pre><code>## Learner classif.qda.preproc from package MASS
## Type: classif
## Name: ; Short name: 
## Class: PreprocWrapperCaret
## Properties: twoclass,multiclass,numerics,factors,prob
## Predict-Type: response
## Hyperparameters: ppc.BoxCox=FALSE,ppc.YeoJohnson=FALSE,ppc.expoTrans=FALSE,ppc.center=TRUE,ppc.scale=TRUE,ppc.range=FALSE,ppc.knnImpute=FALSE,ppc.bagImpute=FALSE,ppc.medianImpute=FALSE,ppc.pca=TRUE,ppc.ica=FALSE,ppc.spatialSign=FALSE,ppc.corr=FALSE,ppc.zv=FALSE,ppc.nzv=FALSE,ppc.thresh=0.9,ppc.na.remove=TRUE,ppc.k=5,ppc.fudge=0.2,ppc.numUnique=3,ppc.cutoff=0.9,ppc.freqCut=19,ppc.uniqueCut=10</code></pre>
<p>The wrapped learner is trained on the [&amp;sonar.task]. By inspecting the underlying <a href="&amp;MASS::qda">qda</a> model, we see that the first 22 principal components have been used for training.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mod =<span class="st"> </span><span class="kw"><a href="../../reference/train.html">train</a></span>(lrn, sonar.task)
mod</code></pre></div>
<pre><code>## Model for learner.id=classif.qda.preproc; learner.class=PreprocWrapperCaret
## Trained on: task.id = Sonar-example; obs = 208; features = 60
## Hyperparameters: ppc.BoxCox=FALSE,ppc.YeoJohnson=FALSE,ppc.expoTrans=FALSE,ppc.center=TRUE,ppc.scale=TRUE,ppc.range=FALSE,ppc.knnImpute=FALSE,ppc.bagImpute=FALSE,ppc.medianImpute=FALSE,ppc.pca=TRUE,ppc.ica=FALSE,ppc.spatialSign=FALSE,ppc.corr=FALSE,ppc.zv=FALSE,ppc.nzv=FALSE,ppc.thresh=0.9,ppc.na.remove=TRUE,ppc.k=5,ppc.fudge=0.2,ppc.numUnique=3,ppc.cutoff=0.9,ppc.freqCut=19,ppc.uniqueCut=10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(mod)</code></pre></div>
<pre><code>## Model for learner.id=classif.qda; learner.class=classif.qda
## Trained on: task.id = Sonar-example; obs = 208; features = 22
## Hyperparameters:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(mod, <span class="dt">more.unwrap =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Call:
## qda(f, data = getTaskData(.task, .subset, recode.target = "drop.levels"))
## 
## Prior probabilities of groups:
##         M         R 
## 0.5336538 0.4663462 
## 
## Group means:
##          PC1        PC2        PC3         PC4         PC5         PC6
## M  0.5976122 -0.8058235  0.9773518  0.03794232 -0.04568166 -0.06721702
## R -0.6838655  0.9221279 -1.1184128 -0.04341853  0.05227489  0.07691845
##          PC7         PC8        PC9       PC10        PC11          PC12
## M  0.2278162 -0.01034406 -0.2530606 -0.1793157 -0.04084466 -0.0004789888
## R -0.2606969  0.01183702  0.2895848  0.2051963  0.04673977  0.0005481212
##          PC13       PC14        PC15        PC16        PC17        PC18
## M -0.06138758 -0.1057137  0.02808048  0.05215865 -0.07453265  0.03869042
## R  0.07024765  0.1209713 -0.03213333 -0.05968671  0.08528994 -0.04427460
##          PC19         PC20        PC21         PC22
## M -0.01192247  0.006098658  0.01263492 -0.001224809
## R  0.01364323 -0.006978877 -0.01445851  0.001401586</code></pre>
<p>Below the performances of <a href="&amp;MASS::qda">qda</a> with and without PCA preprocessing are compared in a <a href="benchmark_experiments.md">benchmark experiment</a>. Note that we use stratified resampling to prevent errors in <a href="&amp;MASS::qda">qda</a> due to a too small number of observations from either class.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rin =<span class="st"> </span><span class="kw"><a href="../../reference/makeResampleInstance.html">makeResampleInstance</a></span>(<span class="st">"CV"</span>, <span class="dt">iters =</span> <span class="dv">3</span>, <span class="dt">stratify =</span> <span class="ot">TRUE</span>, <span class="dt">task =</span> sonar.task)
res =<span class="st"> </span><span class="kw"><a href="../../reference/benchmark.html">benchmark</a></span>(<span class="kw">list</span>(<span class="st">"classif.qda"</span>, lrn), sonar.task, rin, <span class="dt">show.info =</span> <span class="ot">FALSE</span>)
res</code></pre></div>
<pre><code>##         task.id          learner.id mmce.test.mean
## 1 Sonar-example         classif.qda      0.3844030
## 2 Sonar-example classif.qda.preproc      0.2309869</code></pre>
<p>PCA preprocessing in this case turns out to be really beneficial for the performance of Quadratic Discriminant Analysis.</p>
<div id="joint-tuning-of-preprocessing-options-and-learner-parameters" class="section level3">
<h3 class="hasAnchor">
<a href="#joint-tuning-of-preprocessing-options-and-learner-parameters" class="anchor"></a>Joint tuning of preprocessing options and learner parameters</h3>
<p>Let’s see if we can optimize this a bit. The threshold value of 0.9 above was chosen arbitrarily and led to 22 out of 60 principal components. But maybe a lower or higher number of principal components should be used. Moreover, <a href="&amp;MASS::qda">qda</a> has several options that control how the class covariance matrices or class probabilities are estimated.</p>
<p>Those preprocessing and learner parameters can be <a href="tune.md">tuned</a> jointly. Before doing this let’s first get an overview of all the parameters of the wrapped learner using function [&amp;getParamSet].</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/getParamSet.html">getParamSet</a></span>(lrn)</code></pre></div>
<pre><code>##                      Type len     Def                      Constr Req
## ppc.BoxCox        logical   -   FALSE                           -   -
## ppc.YeoJohnson    logical   -   FALSE                           -   -
## ppc.expoTrans     logical   -   FALSE                           -   -
## ppc.center        logical   -    TRUE                           -   -
## ppc.scale         logical   -    TRUE                           -   -
## ppc.range         logical   -   FALSE                           -   -
## ppc.knnImpute     logical   -   FALSE                           -   -
## ppc.bagImpute     logical   -   FALSE                           -   -
## ppc.medianImpute  logical   -   FALSE                           -   -
## ppc.pca           logical   -   FALSE                           -   -
## ppc.ica           logical   -   FALSE                           -   -
## ppc.spatialSign   logical   -   FALSE                           -   -
## ppc.corr          logical   -   FALSE                           -   -
## ppc.zv            logical   -   FALSE                           -   -
## ppc.nzv           logical   -   FALSE                           -   -
## ppc.thresh        numeric   -    0.95                    0 to Inf   -
## ppc.pcaComp       integer   -       -                    1 to Inf   -
## ppc.na.remove     logical   -    TRUE                           -   -
## ppc.k             integer   -       5                    1 to Inf   -
## ppc.fudge         numeric   -     0.2                    0 to Inf   -
## ppc.numUnique     integer   -       3                    1 to Inf   -
## ppc.n.comp        integer   -       -                    1 to Inf   -
## ppc.cutoff        numeric   -     0.9                      0 to 1   -
## ppc.freqCut       numeric   -      19                    1 to Inf   -
## ppc.uniqueCut     numeric   -      10                    0 to Inf   -
## method           discrete   -  moment            moment,mle,mve,t   -
## nu                numeric   -       5                    2 to Inf   Y
## predict.method   discrete   - plug-in plug-in,predictive,debiased   -
##                  Tunable Trafo
## ppc.BoxCox          TRUE     -
## ppc.YeoJohnson      TRUE     -
## ppc.expoTrans       TRUE     -
## ppc.center          TRUE     -
## ppc.scale           TRUE     -
## ppc.range           TRUE     -
## ppc.knnImpute       TRUE     -
## ppc.bagImpute       TRUE     -
## ppc.medianImpute    TRUE     -
## ppc.pca             TRUE     -
## ppc.ica             TRUE     -
## ppc.spatialSign     TRUE     -
## ppc.corr            TRUE     -
## ppc.zv              TRUE     -
## ppc.nzv             TRUE     -
## ppc.thresh          TRUE     -
## ppc.pcaComp         TRUE     -
## ppc.na.remove       TRUE     -
## ppc.k               TRUE     -
## ppc.fudge           TRUE     -
## ppc.numUnique       TRUE     -
## ppc.n.comp          TRUE     -
## ppc.cutoff          TRUE     -
## ppc.freqCut         TRUE     -
## ppc.uniqueCut       TRUE     -
## method              TRUE     -
## nu                  TRUE     -
## predict.method      TRUE     -</code></pre>
<p>The parameters prefixed by <code>ppc.</code> belong to preprocessing. <code>method</code>, <code>nu</code> and <code>predict.method</code> are <a href="&amp;MASS::qda">qda</a> parameters.</p>
<p>Instead of tuning the PCA threshold (<code>ppc.thresh</code>) we tune the number of principal components (<code>ppc.pcaComp</code>) directly. Moreover, for <a href="&amp;MASS::qda">qda</a> we try two different ways to estimate the posterior probabilities (parameter <code>predict.method</code>): the usual plug-in estimates and unbiased estimates.</p>
<p>We perform a grid search and set the resolution to 10. This is for demonstration. You might want to use a finer resolution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ps =<span class="st"> </span><span class="kw">makeParamSet</span>(
  <span class="kw">makeIntegerParam</span>(<span class="st">"ppc.pcaComp"</span>, <span class="dt">lower =</span> <span class="dv">1</span>, <span class="dt">upper =</span> <span class="kw"><a href="../../reference/getTaskNFeats.html">getTaskNFeats</a></span>(sonar.task)),
  <span class="kw">makeDiscreteParam</span>(<span class="st">"predict.method"</span>, <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">"plug-in"</span>, <span class="st">"debiased"</span>))
)
ctrl =<span class="st"> </span><span class="kw"><a href="../../reference/makeTuneControlGrid.html">makeTuneControlGrid</a></span>(<span class="dt">resolution =</span> <span class="dv">10</span>)
res =<span class="st"> </span><span class="kw"><a href="../../reference/tuneParams.html">tuneParams</a></span>(lrn, sonar.task, rin, <span class="dt">par.set =</span> ps, <span class="dt">control =</span> ctrl, <span class="dt">show.info =</span> <span class="ot">FALSE</span>)
res</code></pre></div>
<pre><code>## Tune result:
## Op. pars: ppc.pcaComp=27; predict.method=plug-in
## mmce.test.mean=0.2115252</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.data.frame</span>(res$opt.path)[<span class="dv">1</span>:<span class="dv">3</span>]</code></pre></div>
<pre><code>##    ppc.pcaComp predict.method mmce.test.mean
## 1            1        plug-in      0.5095238
## 2            8        plug-in      0.2837129
## 3           14        plug-in      0.2356108
## 4           21        plug-in      0.2309869
## 5           27        plug-in      0.2115252
## 6           34        plug-in      0.2645273
## 7           40        plug-in      0.2306418
## 8           47        plug-in      0.2694272
## 9           53        plug-in      0.2693582
## 10          60        plug-in      0.3844030
## 11           1       debiased      0.5624569
## 12           8       debiased      0.2837819
## 13          14       debiased      0.2450656
## 14          21       debiased      0.2741201
## 15          27       debiased      0.2501725
## 16          34       debiased      0.2790200
## 17          40       debiased      0.2644582
## 18          47       debiased      0.3124224
## 19          53       debiased      0.2692202
## 20          60       debiased      0.3075224</code></pre>
<p>There seems to be a preference for a lower number of principal components (&lt;27) for both <code>"plug-in"</code> and <code>"debiased"</code> with <code>"plug-in"</code> achieving slightly lower error rates.</p>
</div>
</div>
<div id="writing-a-custom-preprocessing-wrapper" class="section level2">
<h2 class="hasAnchor">
<a href="#writing-a-custom-preprocessing-wrapper" class="anchor"></a>Writing a custom preprocessing wrapper</h2>
<p>If the options offered by [&amp;makePreprocWrapperCaret] are not enough, you can write your own preprocessing wrapper using function [&amp;makePreprocWrapper].</p>
<p>As described in the tutorial section about <a href="wrapper.md">wrapped learners</a> wrappers are implemented using a <em>train</em> and a <em>predict</em> method. In case of preprocessing wrappers these methods specify how to transform the data before training and before prediction and are <em>completely user-defined</em>.</p>
<p>Below we show how to create a preprocessing wrapper that centers and scales the data before training/predicting. Some learning methods as, e.g., k nearest neighbors, support vector machines or neural networks usually require scaled features. Many, but not all, have a built-in scaling option where the training data set is scaled before model fitting and the test data set is scaled accordingly, that is by using the scaling parameters from the training stage, before making predictions. In the following we show how to add a scaling option to a <a href="&amp;makeLearner">Learner</a> by coupling it with function <a href="&amp;base::scale">scale</a>.</p>
<p>Note that we chose this simple example for demonstration. Centering/scaling the data is also possible with [&amp;makePreprocWrapperCaret].</p>
<div id="specifying-the-train-function" class="section level3">
<h3 class="hasAnchor">
<a href="#specifying-the-train-function" class="anchor"></a>Specifying the train function</h3>
<p>The <em>train</em> function has to be a function with the following arguments:</p>
<ul>
<li>
<code>data</code> is a <a href="&amp;base::data.frame">data.frame</a> with columns for all features and the target variable.</li>
<li>
<code>target</code> is a string and denotes the name of the target variable in <code>data</code>.</li>
<li>
<code>args</code> is a <a href="&amp;base::list">list</a> of further arguments and parameters that influence the preprocessing.</li>
</ul>
<p>It must return a <a href="&amp;base::list">list</a> with elements <code>$data</code> and <code>$control</code>, where <code>$data</code> is the preprocessed data set and <code>$control</code> stores all information required to preprocess the data before prediction.</p>
<p>The <em>train</em> function for the scaling example is given below. It calls <a href="&amp;base::scale">scale</a> on the numerical features and returns the scaled training data and the corresponding scaling parameters.</p>
<p><code>args</code> contains the <code>center</code> and <code>scale</code> arguments of function <a href="&amp;base::scale">scale</a> and slot <code>$control</code> stores the scaling parameters to be used in the prediction stage.</p>
<p>Regarding the latter note that the <code>center</code> and <code>scale</code> arguments of <a href="&amp;base::scale">scale</a> can be either a logical value or a numeric vector of length equal to the number of the numeric columns in <code>data</code>, respectively. If a logical value was passed to <code>args</code> we store the column means and standard deviations/ root mean squares in the <code>$center</code> and <code>$scale</code> slots of the returned <code>$control</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainfun =<span class="st"> </span>function(data, target, <span class="dt">args =</span> <span class="kw">list</span>(center, scale)) {
  ## Identify numerical features
  cns =<span class="st"> </span><span class="kw">colnames</span>(data)
  nums =<span class="st"> </span><span class="kw">setdiff</span>(cns[<span class="kw">sapply</span>(data, is.numeric)], target)
  ## Extract numerical features from the data set and call scale
  x =<span class="st"> </span><span class="kw">as.matrix</span>(data[, nums, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
  x =<span class="st"> </span><span class="kw">scale</span>(x, <span class="dt">center =</span> args$center, <span class="dt">scale =</span> args$scale)
  ## Store the scaling parameters in control
  ## These are needed to preprocess the data before prediction
  control =<span class="st"> </span>args
  if (<span class="kw">is.logical</span>(control$center) &amp;&amp;<span class="st"> </span>control$center)
    control$center =<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">"scaled:center"</span>)
  if (<span class="kw">is.logical</span>(control$scale) &amp;&amp;<span class="st"> </span>control$scale)
    control$scale =<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">"scaled:scale"</span>)
  ## Recombine the data
  data =<span class="st"> </span>data[, <span class="kw">setdiff</span>(cns, nums), drop =<span class="st"> </span><span class="ot">FALSE</span>]
  data =<span class="st"> </span><span class="kw">cbind</span>(data, <span class="kw">as.data.frame</span>(x))
  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">data =</span> data, <span class="dt">control =</span> control))
}</code></pre></div>
</div>
<div id="specifying-the-predict-function" class="section level3">
<h3 class="hasAnchor">
<a href="#specifying-the-predict-function" class="anchor"></a>Specifying the predict function</h3>
<p>The <em>predict</em> function has the following arguments:</p>
<ul>
<li>
<code>data</code> is a <a href="&amp;base::data.frame">data.frame</a> containing <em>only</em> feature values (as for prediction the target values naturally are not known).</li>
<li>
<code>target</code> is a string indicating the name of the target variable.</li>
<li>
<code>args</code> are the <code>args</code> that were passed to the <em>train</em> function.</li>
<li>
<code>control</code> is the object returned by the <em>train</em> function.</li>
</ul>
<p>It returns the preprocessed data.</p>
<p>In our scaling example the <em>predict</em> function scales the numerical features using the parameters from the training stage stored in <code>control</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictfun =<span class="st"> </span>function(data, target, args, control) {
  ## Identify numerical features
  cns =<span class="st"> </span><span class="kw">colnames</span>(data)
  nums =<span class="st"> </span>cns[<span class="kw">sapply</span>(data, is.numeric)]
  ## Extract numerical features from the data set and call scale
  x =<span class="st"> </span><span class="kw">as.matrix</span>(data[, nums, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
  x =<span class="st"> </span><span class="kw">scale</span>(x, <span class="dt">center =</span> control$center, <span class="dt">scale =</span> control$scale)
  ## Recombine the data
  data =<span class="st"> </span>data[, <span class="kw">setdiff</span>(cns, nums), drop =<span class="st"> </span><span class="ot">FALSE</span>]
  data =<span class="st"> </span><span class="kw">cbind</span>(data, <span class="kw">as.data.frame</span>(x))
  <span class="kw">return</span>(data)
}</code></pre></div>
</div>
<div id="creating-the-preprocessing-wrapper" class="section level3">
<h3 class="hasAnchor">
<a href="#creating-the-preprocessing-wrapper" class="anchor"></a>Creating the preprocessing wrapper</h3>
<p>Below we create a preprocessing wrapper with a <a href="&amp;nnet::nnet">regression neural network</a> (which itself does not have a scaling option) as base learner.</p>
<p>The <em>train</em> and <em>predict</em> functions defined above are passed to [&amp;makePreprocWrapper] via the <code>train</code> and <code>predict</code> arguments. <code>par.vals</code> is a <a href="&amp;base::list">list</a> of parameter values that is relayed to the <code>args</code> argument of the <em>train</em> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="st">"regr.nnet"</span>, <span class="dt">trace =</span> <span class="ot">FALSE</span>, <span class="dt">decay =</span> <span class="fl">1e-02</span>)
lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makePreprocWrapper.html">makePreprocWrapper</a></span>(lrn, <span class="dt">train =</span> trainfun, <span class="dt">predict =</span> predictfun,
  <span class="dt">par.vals =</span> <span class="kw">list</span>(<span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">TRUE</span>))
lrn</code></pre></div>
<pre><code>## Learner regr.nnet.preproc from package nnet
## Type: regr
## Name: ; Short name: 
## Class: PreprocWrapper
## Properties: numerics,factors,weights
## Predict-Type: response
## Hyperparameters: size=3,trace=FALSE,decay=0.01</code></pre>
<p>Let’s compare the cross-validated mean squared error (<a href="measures.md">mse</a>) on the <a href="&amp;mlbench::BostonHousing">Boston Housing data set</a> with and without scaling.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rdesc =<span class="st"> </span><span class="kw"><a href="../../reference/makeResampleDesc.html">makeResampleDesc</a></span>(<span class="st">"CV"</span>, <span class="dt">iters =</span> <span class="dv">3</span>)

r =<span class="st"> </span><span class="kw"><a href="../../reference/resample.html">resample</a></span>(lrn, bh.task, <span class="dt">resampling =</span> rdesc, <span class="dt">show.info =</span> <span class="ot">FALSE</span>)
r</code></pre></div>
<pre><code>## Resample Result
## Task: BostonHousing-example
## Learner: regr.nnet.preproc
## Aggr perf: mse.test.mean=18.4348953
## Runtime: 0.166791</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="st">"regr.nnet"</span>, <span class="dt">trace =</span> <span class="ot">FALSE</span>, <span class="dt">decay =</span> <span class="fl">1e-02</span>)
r =<span class="st"> </span><span class="kw"><a href="../../reference/resample.html">resample</a></span>(lrn, bh.task, <span class="dt">resampling =</span> rdesc, <span class="dt">show.info =</span> <span class="ot">FALSE</span>)
r</code></pre></div>
<pre><code>## Resample Result
## Task: BostonHousing-example
## Learner: regr.nnet
## Aggr perf: mse.test.mean=55.6276543
## Runtime: 0.0874658</code></pre>
</div>
<div id="joint-tuning-of-preprocessing-and-learner-parameters" class="section level3">
<h3 class="hasAnchor">
<a href="#joint-tuning-of-preprocessing-and-learner-parameters" class="anchor"></a>Joint tuning of preprocessing and learner parameters</h3>
<p>Often it’s not clear which preprocessing options work best with a certain learning algorithm. As already shown for the number of principal components in [&amp;makePreprocWrapperCaret] we can <a href="tune.md">tune</a> them easily together with other hyperparameters of the learner.</p>
<p>In our scaling example we can try if <a href="&amp;nnet::nnet">nnet</a> works best with both centering and scaling the data or if it’s better to omit one of the two operations or do no preprocessing at all. In order to tune <code>center</code> and <code>scale</code> we have to add appropriate <a href="&amp;ParamHelpers::LearnerParam">LearnerParam</a>s to the <a href="&amp;ParamHelpers::ParamSet">parameter set</a> of the wrapped learner.</p>
<p>As mentioned above <a href="&amp;base::scale">scale</a> allows for numeric and logical <code>center</code> and <code>scale</code> arguments. As we want to use the latter option we declare <code>center</code> and <code>scale</code> as logical learner parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="st">"regr.nnet"</span>, <span class="dt">trace =</span> <span class="ot">FALSE</span>)
lrn =<span class="st"> </span><span class="kw"><a href="../../reference/makePreprocWrapper.html">makePreprocWrapper</a></span>(lrn, <span class="dt">train =</span> trainfun, <span class="dt">predict =</span> predictfun,
  <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
    <span class="kw">makeLogicalLearnerParam</span>(<span class="st">"center"</span>),
    <span class="kw">makeLogicalLearnerParam</span>(<span class="st">"scale"</span>)
  ),
  <span class="dt">par.vals =</span> <span class="kw">list</span>(<span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">TRUE</span>))

lrn</code></pre></div>
<pre><code>## Learner regr.nnet.preproc from package nnet
## Type: regr
## Name: ; Short name: 
## Class: PreprocWrapper
## Properties: numerics,factors,weights
## Predict-Type: response
## Hyperparameters: size=3,trace=FALSE,center=TRUE,scale=TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../../reference/getParamSet.html">getParamSet</a></span>(lrn)</code></pre></div>
<pre><code>##             Type len    Def      Constr Req Tunable Trafo
## center   logical   -      -           -   -    TRUE     -
## scale    logical   -      -           -   -    TRUE     -
## size     integer   -      3    0 to Inf   -    TRUE     -
## maxit    integer   -    100    1 to Inf   -    TRUE     -
## linout   logical   -  FALSE           -   Y    TRUE     -
## entropy  logical   -  FALSE           -   Y    TRUE     -
## softmax  logical   -  FALSE           -   Y    TRUE     -
## censored logical   -  FALSE           -   Y    TRUE     -
## skip     logical   -  FALSE           -   -    TRUE     -
## rang     numeric   -    0.7 -Inf to Inf   -    TRUE     -
## decay    numeric   -      0    0 to Inf   -    TRUE     -
## Hess     logical   -  FALSE           -   -    TRUE     -
## trace    logical   -   TRUE           -   -   FALSE     -
## MaxNWts  integer   -   1000    1 to Inf   -   FALSE     -
## abstol   numeric   - 0.0001 -Inf to Inf   -    TRUE     -
## reltol   numeric   -  1e-08 -Inf to Inf   -    TRUE     -</code></pre>
<p>Now we do a simple grid search for the <code>decay</code> parameter of <a href="&amp;nnet::nnet">nnet</a> and the <code>center</code> and <code>scale</code> parameters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rdesc =<span class="st"> </span><span class="kw"><a href="../../reference/makeResampleDesc.html">makeResampleDesc</a></span>(<span class="st">"Holdout"</span>)
ps =<span class="st"> </span><span class="kw">makeParamSet</span>(
  <span class="kw">makeDiscreteParam</span>(<span class="st">"decay"</span>, <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="fl">0.1</span>)),
  <span class="kw">makeLogicalParam</span>(<span class="st">"center"</span>),
  <span class="kw">makeLogicalParam</span>(<span class="st">"scale"</span>)
)
ctrl =<span class="st"> </span><span class="kw"><a href="../../reference/makeTuneControlGrid.html">makeTuneControlGrid</a></span>()
res =<span class="st"> </span><span class="kw"><a href="../../reference/tuneParams.html">tuneParams</a></span>(lrn, bh.task, rdesc, <span class="dt">par.set =</span> ps, <span class="dt">control =</span> ctrl, <span class="dt">show.info =</span> <span class="ot">FALSE</span>)

res</code></pre></div>
<pre><code>## Tune result:
## Op. pars: decay=0.1; center=FALSE; scale=TRUE
## mse.test.mean=12.6915057</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.data.frame</span>(res$opt.path)</code></pre></div>
<pre><code>##    decay center scale mse.test.mean dob eol error.message exec.time
## 1      0   TRUE  TRUE      27.14874   1  NA          &lt;NA&gt;     0.055
## 2   0.05   TRUE  TRUE      17.88331   2  NA          &lt;NA&gt;     0.050
## 3    0.1   TRUE  TRUE      21.25900   3  NA          &lt;NA&gt;     0.050
## 4      0  FALSE  TRUE      17.97903   4  NA          &lt;NA&gt;     0.039
## 5   0.05  FALSE  TRUE      15.07287   5  NA          &lt;NA&gt;     0.041
## 6    0.1  FALSE  TRUE      12.69151   6  NA          &lt;NA&gt;     0.044
## 7      0   TRUE FALSE      62.05392   7  NA          &lt;NA&gt;     0.039
## 8   0.05   TRUE FALSE      75.18249   8  NA          &lt;NA&gt;     0.043
## 9    0.1   TRUE FALSE      51.38191   9  NA          &lt;NA&gt;     0.046
## 10     0  FALSE FALSE      88.35734  10  NA          &lt;NA&gt;     0.022
## 11  0.05  FALSE FALSE      19.82580  11  NA          &lt;NA&gt;     0.049
## 12   0.1  FALSE FALSE      30.46040  12  NA          &lt;NA&gt;     0.052</code></pre>
</div>
<div id="preprocessing-wrapper-functions" class="section level3">
<h3 class="hasAnchor">
<a href="#preprocessing-wrapper-functions" class="anchor"></a>Preprocessing wrapper functions</h3>
<p>If you have written a preprocessing wrapper that you might want to use from time to time it’s a good idea to encapsulate it in an own function as shown below. If you think your preprocessing method is something others might want to use as well and should be integrated into [%mlr] just <a href="https://github.com/mlr-org/mlr/issues">contact us</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makePreprocWrapperScale =<span class="st"> </span>function(learner, <span class="dt">center =</span> <span class="ot">TRUE</span>, <span class="dt">scale =</span> <span class="ot">TRUE</span>) {
  trainfun =<span class="st"> </span>function(data, target, <span class="dt">args =</span> <span class="kw">list</span>(center, scale)) {
    cns =<span class="st"> </span><span class="kw">colnames</span>(data)
    nums =<span class="st"> </span><span class="kw">setdiff</span>(cns[<span class="kw">sapply</span>(data, is.numeric)], target)
    x =<span class="st"> </span><span class="kw">as.matrix</span>(data[, nums, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
    x =<span class="st"> </span><span class="kw">scale</span>(x, <span class="dt">center =</span> args$center, <span class="dt">scale =</span> args$scale)
    control =<span class="st"> </span>args
    if (<span class="kw">is.logical</span>(control$center) &amp;&amp;<span class="st"> </span>control$center)
      control$center =<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">"scaled:center"</span>)
    if (<span class="kw">is.logical</span>(control$scale) &amp;&amp;<span class="st"> </span>control$scale)
      control$scale =<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">"scaled:scale"</span>)
    data =<span class="st"> </span>data[, <span class="kw">setdiff</span>(cns, nums), drop =<span class="st"> </span><span class="ot">FALSE</span>]
    data =<span class="st"> </span><span class="kw">cbind</span>(data, <span class="kw">as.data.frame</span>(x))
    <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">data =</span> data, <span class="dt">control =</span> control))
  }
  predictfun =<span class="st"> </span>function(data, target, args, control) {
    cns =<span class="st"> </span><span class="kw">colnames</span>(data)
    nums =<span class="st"> </span>cns[<span class="kw">sapply</span>(data, is.numeric)]
    x =<span class="st"> </span><span class="kw">as.matrix</span>(data[, nums, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
    x =<span class="st"> </span><span class="kw">scale</span>(x, <span class="dt">center =</span> control$center, <span class="dt">scale =</span> control$scale)
    data =<span class="st"> </span>data[, <span class="kw">setdiff</span>(cns, nums), drop =<span class="st"> </span><span class="ot">FALSE</span>]
    data =<span class="st"> </span><span class="kw">cbind</span>(data, <span class="kw">as.data.frame</span>(x))
    <span class="kw">return</span>(data)
  }
  <span class="kw"><a href="../../reference/makePreprocWrapper.html">makePreprocWrapper</a></span>(
    learner,
    <span class="dt">train =</span> trainfun,
    <span class="dt">predict =</span> predictfun,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeLogicalLearnerParam</span>(<span class="st">"center"</span>),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="st">"scale"</span>)
    ),
    <span class="dt">par.vals =</span> <span class="kw">list</span>(<span class="dt">center =</span> center, <span class="dt">scale =</span> scale)
  )
}

lrn =<span class="st"> </span><span class="kw">makePreprocWrapperScale</span>(<span class="st">"classif.lda"</span>)
<span class="kw"><a href="../../reference/train.html">train</a></span>(lrn, iris.task)</code></pre></div>
<pre><code>## Model for learner.id=classif.lda.preproc; learner.class=PreprocWrapper
## Trained on: task.id = iris-example; obs = 150; features = 4
## Hyperparameters: center=TRUE,scale=TRUE</code></pre>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#fusing-learners-with-preprocessing">Fusing learners with preprocessing</a></li>
      <li><a href="#preprocessing-with-makepreprocwrappercaret">Preprocessing with makePreprocWrapperCaret</a></li>
      <li><a href="#writing-a-custom-preprocessing-wrapper">Writing a custom preprocessing wrapper</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bernd Bischl, Michel Lang, Lars Kotthoff, Julia Schiffner, Jakob Richter, Zachary Jones, Giuseppe Casalicchio, Mason Gallo.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
