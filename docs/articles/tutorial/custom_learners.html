<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Integrating Another Learner • mlr</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../../pkgdown.css" rel="stylesheet">
<script src="../../jquery.sticky-kit.min.js"></script><script src="../../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../../index.html">mlr</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../../articles/mlr.html">Get Started</a>
</li>
<li>
  <a href="../../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Basics
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/task.html">Tasks</a>
    </li>
    <li>
      <a href="../../articles/tutorial/learners.html">Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/predict.html">Predict</a>
    </li>
    <li>
      <a href="../../articles/tutorial/performance.html">Performance</a>
    </li>
    <li>
      <a href="../../articles/tutorial/resample.html">Resampling</a>
    </li>
    <li>
      <a href="../../articles/tutorial/tune.html">Tuning</a>
    </li>
    <li>
      <a href="../../articles/tutorial/benchmark_experiments.html">Benchmark Experiments</a>
    </li>
    <li>
      <a href="../../articles/tutorial/parallelization.html">Parallelization</a>
    </li>
    <li>
      <a href="../../articles/tutorial/visualization.html">Visualization</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Advanced
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/configuring.html">Configuration</a>
    </li>
    <li>
      <a href="../../articles/tutorial/wrapper.html">Wrapped Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/preproc.html">Preprocessing</a>
    </li>
    <li>
      <a href="../../articles/tutorial/impute.html">Imputation</a>
    </li>
    <li>
      <a href="../../articles/tutorial/bagging.html">Generic Bagging</a>
    </li>
    <li>
      <a href="../../articles/tutorial/advanced_tune.html">Advanced Tuning</a>
    </li>
    <li>
      <a href="../../articles/tutorial/feature_selection.html">Feature Selection</a>
    </li>
    <li>
      <a href="../../articles/tutorial/nested_resampling.html">Nested Resampling</a>
    </li>
    <li>
      <a href="../../articles/tutorial/cost_sensitive_classif.html">Cost-Sensitive Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial/imbalanced_classification_problems.html">Imbalanced Classification Problems</a>
    </li>
    <li>
      <a href="../../articles/tutorial/roc_analysis.html">ROC Analysis and Performance Curves</a>
    </li>
    <li>
      <a href="../../articles/tutorial/multilabel.html">Multilabel Classification</a>
    </li>
    <li>
      <a href="../../articles/tutorial/learning_curve_analysis.html">Learning Curve Analysis</a>
    </li>
    <li>
      <a href="../../articles/tutorial/partial_dependence.html">Partial Dependence Plots</a>
    </li>
    <li>
      <a href="../../articles/tutorial/classifier_calibration.html">Classifier Calibration</a>
    </li>
    <li>
      <a href="../../articles/tutorial/hyperparameter_tuning_effects.html">Hyperparameter Tuning Effects</a>
    </li>
    <li>
      <a href="../../articles/tutorial/out_of_bag_predictions.html">Out-of-Bag Predictions</a>
    </li>
    <li>
      <a href="../../articles/tutorial/handling_of_spatial_data.html">Handling of Spatial Data</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Extend
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/custom_learners.html">Create Custom Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/custom_measures.html">Create Custom Measures</a>
    </li>
    <li>
      <a href="../../articles/tutorial/create_imputation.html">Create Imputation Methods</a>
    </li>
    <li>
      <a href="../../articles/tutorial/create_filter.html">Create Custom Filters</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Appendix
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../../articles/tutorial/example_tasks.html">Example Tasks</a>
    </li>
    <li>
      <a href="../../articles/tutorial/integrated_learners.html">Integrated Learners</a>
    </li>
    <li>
      <a href="../../articles/tutorial/implemented_measures.html">Implemented Measures</a>
    </li>
    <li>
      <a href="../../articles/tutorial/filter_methods.html">Integrated Filter Methods</a>
    </li>
  </ul>
</li>
<li>
  <a href="../../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/mlr-org/mlr">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<form class="navbar-form" role="search" method="GET" action="../../search.html">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search" id="search" name="search">
</div>
        <button type="submit" class="btn btn-default">
          <i class="glyphicon glyphicon-search"></i>
        </button>
      </form>
    </div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Integrating Another Learner</h1>
            
          </div>

    
    
<div class="contents">
<p>In order to integrate a learning algorithm into [%mlr] some interface code has to be written. Three functions are mandatory for each learner.</p>
<ul>
<li>First, define a new learner class with a name, description, capabilities, parameters, and a few other things. (An object of this class can then be generated by [&amp;makeLearner].)</li>
<li>Second, you need to provide a function that calls the learner function and builds the model given data (which makes it possible to invoke training by calling [%mlr]’s [&amp;train] function).</li>
<li>Finally, a prediction function that returns predicted values given new data is required (which enables invoking prediction by calling [%mlr]’s <a href="&amp;predict.WrappedModel">predict</a> function).</li>
</ul>
<p>Technically, integrating a learning method means introducing a new S3 <a href="&amp;base::class">class</a> and implementing the corresponding methods for the generic functions <a href="&amp;RLearner">makeRLerner</a>, [&amp;trainLearner], and [&amp;predictLearner]. Therefore we start with a quick overview of the involved <a href="&amp;base::class">classes</a> and constructor functions.</p>
<div id="classes-constructors-and-naming-schemes" class="section level2">
<h2 class="hasAnchor">
<a href="#classes-constructors-and-naming-schemes" class="anchor"></a>Classes, constructors, and naming schemes</h2>
<p>As you already know [&amp;makeLearner] generates an object of class <a href="&amp;makeLearner">Learner</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="dt">cl =</span> <span class="st">"classif.lda"</span>))</code></pre></div>
<pre><code>## [1] "classif.lda"     "RLearnerClassif" "RLearner"        "Learner"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="dt">cl =</span> <span class="st">"regr.lm"</span>))</code></pre></div>
<pre><code>## [1] "regr.lm"      "RLearnerRegr" "RLearner"     "Learner"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="dt">cl =</span> <span class="st">"surv.coxph"</span>))</code></pre></div>
<pre><code>## [1] "surv.coxph"   "RLearnerSurv" "RLearner"     "Learner"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="dt">cl =</span> <span class="st">"cluster.kmeans"</span>))</code></pre></div>
<pre><code>## [1] "cluster.kmeans"  "RLearnerCluster" "RLearner"        "Learner"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw"><a href="../../reference/makeLearner.html">makeLearner</a></span>(<span class="dt">cl =</span> <span class="st">"multilabel.rFerns"</span>))</code></pre></div>
<pre><code>## [1] "multilabel.rFerns"  "RLearnerMultilabel" "RLearner"          
## [4] "Learner"</code></pre>
<p>The first element of each <a href="&amp;base::class">class</a> attribute vector is the name of the learner class passed to the <code>cl</code> argument of [&amp;makeLearner]. Obviously, this adheres to the naming conventions</p>
<ul>
<li>
<code>"classif.&lt;R_method_name&gt;"</code> for classification,</li>
<li>
<code>"multilabel.&lt;R_method_name&gt;"</code> for multilabel classification,</li>
<li>
<code>"regr.&lt;R_method_name&gt;"</code> for regression,</li>
<li>
<code>"surv.&lt;R_method_name&gt;"</code> for survival analysis, and</li>
<li>
<code>"cluster.&lt;R_method_name&gt;"</code> for clustering.</li>
</ul>
<p>Additionally, there exist intermediate classes that reflect the type of learning problem, i.e., all classification learners inherit from <a href="&amp;RLearner">RLearnerClassif</a>, all regression learners from <a href="&amp;RLearner">RLearnerRegr</a> and so on. Their superclasses are [&amp;RLearner] and finally <a href="&amp;makeLearner">Learner</a>. For all these (sub)classes there exist constructor functions <a href="&amp;RLearner">makeRLearner</a>, <a href="&amp;RLearner">makeRLearnerClassif</a>, <a href="&amp;RLearner">makeRLearneRegr</a> etc. that are called internally by [&amp;makeLearner].</p>
<p>A short side remark: As you might have noticed there does not exist a special learner class for <a href="cost_sensitive_classif.md">cost-sensitive classification (costsens)</a> with example-specific costs. This type of learning task is currently exclusively handled through <a href="wrapper.md">wrappers</a> like [&amp;makeCostSensWeightedPairsWrapper].</p>
<p>In the following we show how to integrate learners for the five types of learning tasks mentioned above. Defining a completely new type of learner that has special properties and does not fit into one of the existing schemes is of course possible, but much more advanced and not covered here.</p>
<p>We use a classification example to explain some general principles (so even if you are interested in integrating a learner for another type of learning task you might want to read the following section). Examples for other types of learning tasks are shown later on.</p>
</div>
<div id="classification" class="section level2">
<h2 class="hasAnchor">
<a href="#classification" class="anchor"></a>Classification</h2>
<p>We show how the <a href="&amp;MASS::lda">Linear Discriminant Analysis</a> from package [%MASS] has been integrated into the classification learner <code>classif.lda</code> in [%mlr] as an example.</p>
<div id="definition-of-the-learner" class="section level3">
<h3 class="hasAnchor">
<a href="#definition-of-the-learner" class="anchor"></a>Definition of the learner</h3>
<p>The minimal information required to define a learner is the [%mlr] name of the learner, its package, the parameter set, and the set of properties of your learner. In addition, you may provide a human-readable name, a short name and a note with information relevant to users of the learner.</p>
<p>First, name your learner. According to the naming conventions above the name starts with <code>classif.</code> and we choose <code>classif.lda</code>.</p>
<p>Second, we need to define the parameters of the learner. These are any options that can be set when running it to change how it learns, how input is interpreted, how and what output is generated, and so on. [%mlr] provides a number of functions to define parameters, a complete list can be found in the documentation of <a href="&amp;ParamHelpers::LearnerParam">LearnerParam</a> of the [%ParamHelpers] package.</p>
<p>In our example, we have discrete and numeric parameters, so we use <a href="&amp;ParamHelpers::LearnerParam">makeDiscreteLearnerParam</a> and <a href="&amp;ParamHelpers::LearnerParam">makeNumericLearnerParam</a> to incorporate the complete description of the parameters. We include all possible values for discrete parameters and lower and upper bounds for numeric parameters. Strictly speaking it is not necessary to provide bounds for all parameters and if this information is not available they can be estimated, but providing accurate and specific information here makes it possible to tune the learner much better (see the section on <a href="tune.md">tuning</a>).</p>
<p>Next, we add information on the properties of the learner (see also the section on <a href="learner.md">learners</a>). Which types of features are supported (numerics, factors)? Are case weights supported? Are class weights supported? Can the method deal with missing values in the features and deal with NA’s in a meaningful way (not <code>na.omit</code>)? Are one-class, two-class, multi-class problems supported? Can the learner predict posterior probabilities?</p>
<p>If the learner supports class weights the name of the relevant learner parameter can be specified via argument <code>class.weights.param</code>.</p>
<p>Below is the complete code for the definition of the LDA learner. It has one discrete parameter, <code>method</code>, and two continuous ones, <code>nu</code> and <code>tol</code>. It supports classification problems with two or more classes and can deal with numeric and factor explanatory variables. It can predict posterior probabilities.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeRLearner.classif.lda =<span class="st"> </span>function() {
  <span class="kw"><a href="../../reference/RLearner.html">makeRLearnerClassif</a></span>(
    <span class="dt">cl =</span> <span class="st">"classif.lda"</span>,
    <span class="dt">package =</span> <span class="st">"MASS"</span>,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeDiscreteLearnerParam</span>(<span class="dt">id =</span> <span class="st">"method"</span>, <span class="dt">default =</span> <span class="st">"moment"</span>, <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">"moment"</span>, <span class="st">"mle"</span>, <span class="st">"mve"</span>, <span class="st">"t"</span>)),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"nu"</span>, <span class="dt">lower =</span> <span class="dv">2</span>, <span class="dt">requires =</span> <span class="kw">quote</span>(method ==<span class="st"> "t"</span>)),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"tol"</span>, <span class="dt">default =</span> <span class="fl">1e-4</span>, <span class="dt">lower =</span> <span class="dv">0</span>),
      <span class="kw">makeDiscreteLearnerParam</span>(<span class="dt">id =</span> <span class="st">"predict.method"</span>, <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">"plug-in"</span>, <span class="st">"predictive"</span>, <span class="st">"debiased"</span>),
        <span class="dt">default =</span> <span class="st">"plug-in"</span>, <span class="dt">when =</span> <span class="st">"predict"</span>),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"CV"</span>, <span class="dt">default =</span> <span class="ot">FALSE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>)
    ),
    <span class="dt">properties =</span> <span class="kw">c</span>(<span class="st">"twoclass"</span>, <span class="st">"multiclass"</span>, <span class="st">"numerics"</span>, <span class="st">"factors"</span>, <span class="st">"prob"</span>),
    <span class="dt">name =</span> <span class="st">"Linear Discriminant Analysis"</span>,
    <span class="dt">short.name =</span> <span class="st">"lda"</span>,
    <span class="dt">note =</span> <span class="st">"Learner param 'predict.method' maps to 'method' in predict.lda."</span>
  )
}</code></pre></div>
</div>
<div id="creating-the-training-function-of-the-learner" class="section level3">
<h3 class="hasAnchor">
<a href="#creating-the-training-function-of-the-learner" class="anchor"></a>Creating the training function of the learner</h3>
<p>Once the learner has been defined, we need to tell [%mlr] how to call it to train a model. The name of the function has to start with <code>trainLearner.</code>, followed by the [%mlr] name of the learner as defined above (<code>classif.lda</code> here). The prototype of the function looks as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">function(.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) { }</code></pre></div>
<p>This function must fit a model on the data of the task <code>.task</code> with regard to the subset defined in the integer vector <code>.subset</code> and the parameters passed in the <code>...</code> arguments. Usually, the data should be extracted from the task using [&amp;getTaskData]. This will take care of any subsetting as well. It must return the fitted model. [%mlr] assumes no special data type for the return value – it will be passed to the predict function we are going to define below, so any special code the learner may need can be encapsulated there.</p>
<p>For our example, the definition of the function looks like this. In addition to the data of the task, we also need the formula that describes what to predict. We use the function [&amp;getTaskFormula] to extract this from the task.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainLearner.classif.lda =<span class="st"> </span>function (.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) 
{
    f =<span class="st"> </span><span class="kw"><a href="../../reference/getTaskFormula.html">getTaskFormula</a></span>(.task)
    MASS::<span class="kw">lda</span>(f, <span class="dt">data =</span> <span class="kw"><a href="../../reference/getTaskData.html">getTaskData</a></span>(.task, .subset), ...)
}</code></pre></div>
</div>
<div id="creating-the-prediction-method" class="section level3">
<h3 class="hasAnchor">
<a href="#creating-the-prediction-method" class="anchor"></a>Creating the prediction method</h3>
<p>Finally, the prediction function needs to be defined. The name of this function starts with <code>predictLearner.</code>, followed again by the [%mlr] name of the learner. The prototype of the function is as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">function(.learner, .model, .newdata, ...) { }</code></pre></div>
<p>It must predict for the new observations in the <code>data.frame</code> <code>.newdata</code> with the wrapped model <code>.model</code>, which is returned from the training function. The actual model the learner built is stored in the <code>$learner.model</code> member and can be accessed simply through <code>.model$learner.model</code>.</p>
<p>For classification, you have to return a factor of predicted classes if <code>.learner$predict.type</code> is <code>"response"</code>, or a matrix of predicted probabilities if <code>.learner$predict.type</code> is <code>"prob"</code> and this type of prediction is supported by the learner. In the latter case the matrix must have the same number of columns as there are classes in the task and the columns have to be named by the class names.</p>
<p>The definition for LDA looks like this. It is pretty much just a straight pass-through of the arguments to the <a href="&amp;base::predict">predict</a> function and some extraction of prediction data depending on the type of prediction requested.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictLearner.classif.lda =<span class="st"> </span>function (.learner, .model, .newdata, <span class="dt">predict.method =</span> <span class="st">"plug-in"</span>, 
    ...) 
{
    p =<span class="st"> </span><span class="kw">predict</span>(.model$learner.model, <span class="dt">newdata =</span> .newdata, <span class="dt">method =</span> predict.method, 
        ...)
    if (.learner$predict.type ==<span class="st"> "response"</span>) 
        <span class="kw">return</span>(p$class)
    else <span class="kw">return</span>(p$posterior)
}</code></pre></div>
</div>
</div>
<div id="regression" class="section level2">
<h2 class="hasAnchor">
<a href="#regression" class="anchor"></a>Regression</h2>
<p>The main difference for regression is that the type of predictions are different (numeric instead of labels or probabilities) and that not all of the properties are relevant. In particular, whether one-, two-, or multi-class problems and posterior probabilities are supported is not applicable.</p>
<p>Apart from this, everything explained above applies. Below is the definition for the <a href="&amp;earth::earth">earth</a> learner from the [%earth] package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeRLearner.regr.earth =<span class="st"> </span>function() {
  <span class="kw"><a href="../../reference/RLearner.html">makeRLearnerRegr</a></span>(
    <span class="dt">cl =</span> <span class="st">"regr.earth"</span>,
    <span class="dt">package =</span> <span class="st">"earth"</span>,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"keepxy"</span>, <span class="dt">default =</span> <span class="ot">FALSE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"trace"</span>, <span class="dt">default =</span> <span class="dv">0</span>, <span class="dt">upper =</span> <span class="dv">10</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"degree"</span>, <span class="dt">default =</span> 1L, <span class="dt">lower =</span> 1L),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"penalty"</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"nk"</span>, <span class="dt">lower =</span> 0L),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"thres"</span>, <span class="dt">default =</span> <span class="fl">0.001</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"minspan"</span>, <span class="dt">default =</span> 0L),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"endspan"</span>, <span class="dt">default =</span> 0L),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"newvar.penalty"</span>, <span class="dt">default =</span> <span class="dv">0</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"fast.k"</span>, <span class="dt">default =</span> 20L, <span class="dt">lower =</span> 0L),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"fast.beta"</span>, <span class="dt">default =</span> <span class="dv">1</span>),
      <span class="kw">makeDiscreteLearnerParam</span>(<span class="dt">id =</span> <span class="st">"pmethod"</span>, <span class="dt">default =</span> <span class="st">"backward"</span>,
        <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">"backward"</span>, <span class="st">"none"</span>, <span class="st">"exhaustive"</span>, <span class="st">"forward"</span>, <span class="st">"seqrep"</span>, <span class="st">"cv"</span>)),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"nprune"</span>)
    ),
    <span class="dt">properties =</span> <span class="kw">c</span>(<span class="st">"numerics"</span>, <span class="st">"factors"</span>),
    <span class="dt">name =</span> <span class="st">"Multivariate Adaptive Regression Splines"</span>,
    <span class="dt">short.name =</span> <span class="st">"earth"</span>,
    <span class="dt">note =</span> <span class="st">""</span>
  )
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainLearner.regr.earth =<span class="st"> </span>function (.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) 
{
    f =<span class="st"> </span><span class="kw"><a href="../../reference/getTaskFormula.html">getTaskFormula</a></span>(.task)
    earth::<span class="kw">earth</span>(f, <span class="dt">data =</span> <span class="kw"><a href="../../reference/getTaskData.html">getTaskData</a></span>(.task, .subset), ...)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictLearner.regr.earth =<span class="st"> </span>function (.learner, .model, .newdata, ...) 
{
    <span class="kw">predict</span>(.model$learner.model, <span class="dt">newdata =</span> .newdata)[, 1L]
}</code></pre></div>
<p>Again most of the data is passed straight through to/from the train/predict functions of the learner.</p>
</div>
<div id="survival-analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#survival-analysis" class="anchor"></a>Survival analysis</h2>
<p>For survival analysis, you have to return so-called linear predictors in order to compute the default measure for this task type, the <a href="measures.md">cindex</a> (for <code>.learner$predict.type</code> == <code>"response"</code>). For <code>.learner$predict.type</code> == <code>"prob"</code>, there is no substantially meaningful measure (yet). You may either ignore this case or return something like predicted survival curves (cf. example below).</p>
<p>There are three properties that are specific to survival learners: “rcens”, “lcens” and “icens”, defining the type(s) of censoring a learner can handle – right, left and/or interval censored.</p>
<p>Let’s have a look at how the <a href="&amp;survival::coxph">Cox Proportional Hazard Model</a> from package [%survival] has been integrated into the survival learner <code>surv.coxph</code> in [%mlr] as an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeRLearner.surv.coxph =<span class="st"> </span>function() {
  <span class="kw"><a href="../../reference/RLearner.html">makeRLearnerSurv</a></span>(
    <span class="dt">cl =</span> <span class="st">"surv.coxph"</span>,
    <span class="dt">package =</span> <span class="st">"survival"</span>,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeDiscreteLearnerParam</span>(<span class="dt">id =</span> <span class="st">"ties"</span>, <span class="dt">default =</span> <span class="st">"efron"</span>, <span class="dt">values =</span> <span class="kw">c</span>(<span class="st">"efron"</span>, <span class="st">"breslow"</span>, <span class="st">"exact"</span>)),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"singular.ok"</span>, <span class="dt">default =</span> <span class="ot">TRUE</span>),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"eps"</span>, <span class="dt">default =</span> <span class="fl">1e-09</span>, <span class="dt">lower =</span> <span class="dv">0</span>),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"toler.chol"</span>, <span class="dt">default =</span> .Machine$double.eps^<span class="fl">0.75</span>, <span class="dt">lower =</span> <span class="dv">0</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"iter.max"</span>, <span class="dt">default =</span> 20L, <span class="dt">lower =</span> 1L),
      <span class="kw">makeNumericLearnerParam</span>(<span class="dt">id =</span> <span class="st">"toler.inf"</span>, <span class="dt">default =</span> <span class="kw">sqrt</span>(.Machine$double.eps^<span class="fl">0.75</span>), <span class="dt">lower =</span> <span class="dv">0</span>),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"outer.max"</span>, <span class="dt">default =</span> 10L, <span class="dt">lower =</span> 1L),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"model"</span>, <span class="dt">default =</span> <span class="ot">FALSE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"x"</span>, <span class="dt">default =</span> <span class="ot">FALSE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"y"</span>, <span class="dt">default =</span> <span class="ot">TRUE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>)
    ),
    <span class="dt">properties =</span> <span class="kw">c</span>(<span class="st">"missings"</span>, <span class="st">"numerics"</span>, <span class="st">"factors"</span>, <span class="st">"weights"</span>, <span class="st">"prob"</span>, <span class="st">"rcens"</span>),
    <span class="dt">name =</span> <span class="st">"Cox Proportional Hazard Model"</span>,
    <span class="dt">short.name =</span> <span class="st">"coxph"</span>,
    <span class="dt">note =</span> <span class="st">""</span>
  )
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainLearner.surv.coxph =<span class="st"> </span>function (.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) 
{
    f =<span class="st"> </span><span class="kw"><a href="../../reference/getTaskFormula.html">getTaskFormula</a></span>(.task)
    data =<span class="st"> </span><span class="kw"><a href="../../reference/getTaskData.html">getTaskData</a></span>(.task, <span class="dt">subset =</span> .subset)
    if (<span class="kw">is.null</span>(.weights)) {
        survival::<span class="kw">coxph</span>(<span class="dt">formula =</span> f, <span class="dt">data =</span> data, ...)
    }
    else {
        survival::<span class="kw">coxph</span>(<span class="dt">formula =</span> f, <span class="dt">data =</span> data, <span class="dt">weights =</span> .weights, 
            ...)
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictLearner.surv.coxph =<span class="st"> </span>function (.learner, .model, .newdata, ...) 
{
    <span class="kw">predict</span>(.model$learner.model, <span class="dt">newdata =</span> .newdata, <span class="dt">type =</span> <span class="st">"lp"</span>, 
        ...)
}</code></pre></div>
</div>
<div id="clustering" class="section level2">
<h2 class="hasAnchor">
<a href="#clustering" class="anchor"></a>Clustering</h2>
<p>For clustering, you have to return a numeric vector with the IDs of the clusters that the respective datum has been assigned to. The numbering should start at 1.</p>
<p>Below is the definition for the <a href="&amp;RWeka::FarthestFirst">FarthestFirst</a> learner from the [%RWeka] package. Weka starts the IDs of the clusters at 0, so we add 1 to the predicted clusters. RWeka has a different way of setting learner parameters; we use the special <code>Weka_control</code> function to do this.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeRLearner.cluster.FarthestFirst =<span class="st"> </span>function() {
  <span class="kw"><a href="../../reference/RLearner.html">makeRLearnerCluster</a></span>(
    <span class="dt">cl =</span> <span class="st">"cluster.FarthestFirst"</span>,
    <span class="dt">package =</span> <span class="st">"RWeka"</span>,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"N"</span>, <span class="dt">default =</span> 2L, <span class="dt">lower =</span> 1L),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"S"</span>, <span class="dt">default =</span> 1L, <span class="dt">lower =</span> 1L),
      <span class="kw">makeLogicalLearnerParam</span>(<span class="dt">id =</span> <span class="st">"output-debug-info"</span>, <span class="dt">default =</span> <span class="ot">FALSE</span>, <span class="dt">tunable =</span> <span class="ot">FALSE</span>)
    ),
    <span class="dt">properties =</span> <span class="kw">c</span>(<span class="st">"numerics"</span>),
    <span class="dt">name =</span> <span class="st">"FarthestFirst Clustering Algorithm"</span>,
    <span class="dt">short.name =</span> <span class="st">"farthestfirst"</span>
  )
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainLearner.cluster.FarthestFirst =<span class="st"> </span>function (.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) 
{
    ctrl =<span class="st"> </span>RWeka::<span class="kw">Weka_control</span>(...)
    RWeka::<span class="kw">FarthestFirst</span>(<span class="kw"><a href="../../reference/getTaskData.html">getTaskData</a></span>(.task, .subset), <span class="dt">control =</span> ctrl)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictLearner.cluster.FarthestFirst =<span class="st"> </span>function (.learner, .model, .newdata, ...) 
{
    <span class="kw">as.integer</span>(<span class="kw">predict</span>(.model$learner.model, .newdata, ...)) +<span class="st"> </span>
<span class="st">        </span>1L
}</code></pre></div>
</div>
<div id="multilabel-classification" class="section level2">
<h2 class="hasAnchor">
<a href="#multilabel-classification" class="anchor"></a>Multilabel classification</h2>
<p>As stated in the <a href="multilabel.md">multilabel</a> section, multilabel classification methods can be divided into problem transformation methods and algorithm adaptation methods.</p>
<p>At this moment the only problem transformation method implemented in [%mlr] is the <a href="&amp;makeMultilabelBinaryRelevanceWrapper">binary relevance method</a>. Integrating more of these methods requires good knowledge of the architecture of the [%mlr] package.</p>
<p>The integration of an algorithm adaptation multilabel classification learner is easier and works very similar to the normal multiclass-classification. In contrast to the multiclass case, not all of the learner properties are relevant. In particular, whether one-, two-, or multi-class problems are supported is not applicable. Furthermore the prediction function output must be a matrix with each prediction of a label in one column and the names of the labels as column names. If <code>.learner$predict.type</code> is <code>"response"</code> the predictions must be logical. If <code>.learner$predict.type</code> is <code>"prob"</code> and this type of prediction is supported by the learner, the matrix must consist of predicted probabilities.</p>
<p>Below is the definition of the <a href="&amp;rFerns::rFerns">rFerns</a> learner from the [%rFerns] package, which does not support probability predictions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">makeRLearner.multilabel.rFerns =<span class="st"> </span>function() {
  <span class="kw"><a href="../../reference/RLearner.html">makeRLearnerMultilabel</a></span>(
    <span class="dt">cl =</span> <span class="st">"multilabel.rFerns"</span>,
    <span class="dt">package =</span> <span class="st">"rFerns"</span>,
    <span class="dt">par.set =</span> <span class="kw">makeParamSet</span>(
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"depth"</span>, <span class="dt">default =</span> 5L),
      <span class="kw">makeIntegerLearnerParam</span>(<span class="dt">id =</span> <span class="st">"ferns"</span>, <span class="dt">default =</span> 1000L)
    ),
    <span class="dt">properties =</span> <span class="kw">c</span>(<span class="st">"numerics"</span>, <span class="st">"factors"</span>, <span class="st">"ordered"</span>),
    <span class="dt">name =</span> <span class="st">"Random ferns"</span>,
    <span class="dt">short.name =</span> <span class="st">"rFerns"</span>,
    <span class="dt">note =</span> <span class="st">""</span>
  )
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trainLearner.multilabel.rFerns =<span class="st"> </span>function (.learner, .task, .subset, <span class="dt">.weights =</span> <span class="ot">NULL</span>, ...) 
{
    d =<span class="st"> </span><span class="kw"><a href="../../reference/getTaskData.html">getTaskData</a></span>(.task, .subset, <span class="dt">target.extra =</span> <span class="ot">TRUE</span>)
    rFerns::<span class="kw">rFerns</span>(<span class="dt">x =</span> d$data, <span class="dt">y =</span> <span class="kw">as.matrix</span>(d$target), ...)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">predictLearner.multilabel.rFerns =<span class="st"> </span>function (.learner, .model, .newdata, ...) 
{
    <span class="kw">as.matrix</span>(<span class="kw">predict</span>(.model$learner.model, .newdata, ...))
}</code></pre></div>
</div>
<div id="creating-a-new-method-for-extracting-feature-importance-values" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-a-new-method-for-extracting-feature-importance-values" class="anchor"></a>Creating a new method for extracting feature importance values</h2>
<p>Some learners, for example decision trees and random forests, can calculate feature importance values, which can be extracted from a <a href="&amp;makeWrappedModel">fitted model</a> using function [&amp;getFeatureImportance].</p>
<p>If your newly integrated learner supports this you need to</p>
<ul>
<li>add <code>"featimp"</code> to the learner properties and</li>
<li>implement a new S3 method for function [&amp;getFeatureImportanceLearner] (which later is called internally by [&amp;getFeatureImportance])</li>
</ul>
<p>in order to make this work.</p>
<p>This method takes the [&amp;Learner] <code>.learner</code>, the <a href="&amp;makeWrappedModel">WrappedModel</a> <code>.model</code> and potential further arguments and calculates or extracts the feature importance. It must return a named vector of importance values.</p>
<p>Below are two simple examples. In case of <code>"classif.rpart"</code> the feature importance values can be easily extracted from the fitted model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">getFeatureImportanceLearner.classif.rpart =<span class="st"> </span>function (.learner, .model, ...) 
{
    mod =<span class="st"> </span><span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(.model, <span class="dt">more.unwrap =</span> <span class="ot">TRUE</span>)
    mod$variable.importance
}</code></pre></div>
<p>For the <a href="&amp;randomForestSRC::rfsrc">random forest</a> from package [%randomForestSRC] function <a href="&amp;randomForestSRC::vimp">vimp</a> is called.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">getFeatureImportanceLearner.classif.randomForestSRC =<span class="st"> </span>function (.learner, .model, ...) 
{
    mod =<span class="st"> </span><span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(.model, <span class="dt">more.unwrap =</span> <span class="ot">TRUE</span>)
    randomForestSRC::<span class="kw">vimp</span>(mod, ...)$importance[, <span class="st">"all"</span>]
}</code></pre></div>
</div>
<div id="creating-a-new-method-for-extracting-out-of-bag-predictions" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-a-new-method-for-extracting-out-of-bag-predictions" class="anchor"></a>Creating a new method for extracting out-of-bag predictions</h2>
<p>Many ensemble learners generate out-of-bag predictions (OOB predictions) automatically. [%mlr] provides the function [&amp;getOOBPreds] to access these predictions in the [%mlr] framework.</p>
<p>If your newly integrated learner is able to calculate OOB predictions and you want to be able to access them in [%mlr] via [&amp;getOOBPreds] you need to</p>
<ul>
<li>add <code>"oobpreds"</code> to the learner properties and</li>
<li>implement a new S3 method for function [&amp;getOOBPredsLearner] (which later is called internally by [&amp;getOOBPreds]).</li>
</ul>
<p>This method takes the <a href="&amp;makeLearner">Learner</a> <code>.learner</code> and the <a href="&amp;makeWrappedModel">WrappedModel</a> <code>.model</code> and extracts the OOB predictions. It must return the predictions in the same format as the [&amp;predictLearner] function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">getOOBPredsLearner.classif.randomForest =<span class="st"> </span>function (.learner, .model) 
{
    if (.learner$predict.type ==<span class="st"> "response"</span>) {
        m =<span class="st"> </span><span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(.model, <span class="dt">more.unwrap =</span> <span class="ot">TRUE</span>)
        <span class="kw">unname</span>(m$predicted)
    }
    else {
        <span class="kw"><a href="../../reference/getLearnerModel.html">getLearnerModel</a></span>(.model, <span class="dt">more.unwrap =</span> <span class="ot">TRUE</span>)$votes
    }
}</code></pre></div>
</div>
<div id="registering-your-learner" class="section level2">
<h2 class="hasAnchor">
<a href="#registering-your-learner" class="anchor"></a>Registering your learner</h2>
<p>If your interface code to a new learning algorithm exists only locally, i.e., it is not (yet) merged into [%mlr] or does not live in an extra package with a proper namespace you might want to register the new S3 methods to make sure that these are found by, e.g., [&amp;listLearners]. You can do this as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">registerS3method</span>(<span class="st">"makeRLearner"</span>, <span class="st">"&lt;awesome_new_learner_class&gt;"</span>, makeRLearner.&lt;awesome_new_learner_class&gt;)
<span class="kw">registerS3method</span>(<span class="st">"trainLearner"</span>, <span class="st">"&lt;awesome_new_learner_class&gt;"</span>, trainLearner.&lt;awesome_new_learner_class&gt;)
<span class="kw">registerS3method</span>(<span class="st">"predictLearner"</span>, <span class="st">"&lt;awesome_new_learner_class&gt;"</span>, predictLearner.&lt;awesome_new_learner_class&gt;)</code></pre></div>
<p>If you have written more methods, for example in order to extract feature importance values or out-of-bag predictions these also need to be registered in the same manner, for example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">registerS3method</span>(<span class="st">"getFeatureImportanceLearner"</span>, <span class="st">"&lt;awesome_new_learner_class&gt;"</span>,
  getFeatureImportanceLearner.&lt;awesome_new_learner_class&gt;)</code></pre></div>
<p>For the new learner to work with parallelization, you may have to export the new methods explicitly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parallelExport</span>(<span class="st">"trainLearner.&lt;awesome_new_learner_class&gt;"</span>, <span class="st">"predictLearner.&lt;awesome_new_learner_class&gt;"</span>)</code></pre></div>
</div>
<div id="further-information-for-developers" class="section level2">
<h2 class="hasAnchor">
<a href="#further-information-for-developers" class="anchor"></a>Further information for developers</h2>
<p>If you haven’t written a learner interface for private use only, but intend to send a pull request to have it included in the [%mlr] package there are a few things to take care of, most importantly unit testing!</p>
<p>For general information about contributing to the package, unit testing, version control setup and the like please also read the <a href="https://github.com/mlr-org/mlr/wiki/mlr-Coding-Guidelines">coding guidelines in the mlr Wiki</a>.</p>
<ul>
<li><p>The R file containing the interface code should adhere to the naming convention <code>RLearner_&lt;type&gt;_&lt;learner_name&gt;.R</code>, e.g., <code>RLearner_classif_lda.R</code>, see for example <a href="https://github.com/mlr-org/mlr/blob/master/R/RLearner_classif_lda.R" class="uri">https://github.com/mlr-org/mlr/blob/master/R/RLearner_classif_lda.R</a> and contain the necessary roxygen <code>@export</code> tags to register the S3 methods in the NAMESPACE.</p></li>
<li><p>The learner interfaces should work out of the box without requiring any parameters to be set, e.g., <code><a href="../../reference/train.html">train("classif.lda", iris.task)</a></code> should run. Sometimes, this makes it necessary to change or set some additional defaults as explained above and – very important – informing the user about this in the <code>note</code>.</p></li>
<li><p>The parameter set of the learner should be as complete as possible.</p></li>
<li><p>Every learner interface must be unit tested.</p></li>
</ul>
<div id="unit-testing" class="section level3">
<h3 class="hasAnchor">
<a href="#unit-testing" class="anchor"></a>Unit testing</h3>
<p>The tests make sure that we get the same results when the learner is invoked through the [%mlr] interface and when using the original functions. If you are not familiar or want to learn more about unit testing and package [%testthat] have a look at <a href="http://r-pkgs.had.co.nz/tests.html">the Testing chapter in Hadley Wickham’s R packages</a>.</p>
<p>In [%mlr] all unit tests are in the following directory: <a href="https://github.com/mlr-org/mlr/tree/master/tests/testthat" class="uri">https://github.com/mlr-org/mlr/tree/master/tests/testthat</a>. For each learner interface there is an individual file whose name follows the scheme <code>test_&lt;type&gt;_&lt;learner_name&gt;.R</code>, for example <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_classif_lda.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_classif_lda.R</a>.</p>
<p>Below is a snippet from the tests of the lda interface <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_classif_lda.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_classif_lda.R</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">test_that</span>(<span class="st">"classif_lda"</span>, {
  <span class="kw">requirePackagesOrSkip</span>(<span class="st">"MASS"</span>, <span class="dt">default.method =</span> <span class="st">"load"</span>)

  <span class="kw">set.seed</span>(<span class="kw">getOption</span>(<span class="st">"mlr.debug.seed"</span>))
  m =<span class="st"> </span>MASS::<span class="kw">lda</span>(<span class="dt">formula =</span> multiclass.formula, <span class="dt">data =</span> multiclass.train)
  <span class="kw">set.seed</span>(<span class="kw">getOption</span>(<span class="st">"mlr.debug.seed"</span>))
  p =<span class="st"> </span><span class="kw">predict</span>(m, <span class="dt">newdata =</span> multiclass.test)

  <span class="kw">testSimple</span>(<span class="st">"classif.lda"</span>, multiclass.df, multiclass.target, multiclass.train.inds, p$class)
  <span class="kw">testProb</span>(<span class="st">"classif.lda"</span>, multiclass.df, multiclass.target, multiclass.train.inds, p$posterior)
})</code></pre></div>
<p>The tests make use of numerous helper objects and helper functions. All of these are defined in the <code>helper_</code> files in <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/</a>.</p>
<p>In the above code the first line just loads package [%MASS] or skips the test if the package is not available. The objects <code>multiclass.formula</code>, <code>multiclass.train</code>, <code>multiclass.test</code> etc. are defined in <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/helper_objects.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/helper_objects.R</a>. We tried to choose fairly self-explanatory names: For example <code>multiclass</code> indicates a multi-class classification problem, <code>multiclass.train</code> contains data for training, <code>multiclass.formula</code> a <a href="&amp;stats::formula">formula</a> object etc.</p>
<p>The test fits an lda model on the training set and makes predictions on the test set using the original functions <a href="&amp;MASS::lda">lda</a> and <a href="&amp;MASS::predict.lda">predict.lda</a>. The helper functions <code>testSimple</code> and <code>testProb</code> perform training and prediction on the same data using the [%mlr] interface – <code>testSimple</code> for <code>predict.type = "response</code> and <code>testProbs</code> for <code>predict.type = "prob"</code> – and check if the predicted class labels and probabilities coincide with the outcomes <code>p$class</code> and <code>p$posterior</code>.</p>
<p>In order to get reproducible results seeding is required for many learners. The <code>"mlr.debug.seed"</code> works as follows: When invoking the tests the option <code>"mlr.debug.seed"</code> is set (see <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/helper_zzz.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/helper_zzz.R</a>), and <code>set.seed(getOption("mlr.debug.seed"))</code> is used to specify the seed. Internally, [%mlr]’s <a href="https://github.com/mlr-org/mlr/blob/master/R/train.R#L73">train</a> and <a href="https://github.com/mlr-org/mlr/blob/master/R/predict.R#L100">predict.WrappedModel</a> functions check if the <code>"mlr.debug.seed"</code> option is set and if yes, also specify the seed.</p>
<p>Note that the option <code>"mlr.debug.seed"</code> is only set for testing, so no seeding happens in normal usage of [%mlr].</p>
<p>Let’s look at a second example. Many learners have parameters that are commonly changed or tuned and it is important to make sure that these are passed through correctly. Below is a snippet from <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_regr_randomForest.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_regr_randomForest.R</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">test_that</span>(<span class="st">"regr_randomForest"</span>, {
  <span class="kw">requirePackagesOrSkip</span>(<span class="st">"randomForest"</span>, <span class="dt">default.method =</span> <span class="st">"load"</span>)

  parset.list =<span class="st"> </span><span class="kw">list</span>(
    <span class="kw">list</span>(),
    <span class="kw">list</span>(<span class="dt">ntree =</span> <span class="dv">5</span>, <span class="dt">mtry =</span> <span class="dv">2</span>),
    <span class="kw">list</span>(<span class="dt">ntree =</span> <span class="dv">5</span>, <span class="dt">mtry =</span> <span class="dv">4</span>),
    <span class="kw">list</span>(<span class="dt">proximity =</span> <span class="ot">TRUE</span>, <span class="dt">oob.prox =</span> <span class="ot">TRUE</span>),
    <span class="kw">list</span>(<span class="dt">nPerm =</span> <span class="dv">3</span>)
  )

  old.predicts.list =<span class="st"> </span><span class="kw">list</span>()

  for (i in <span class="dv">1</span>:<span class="kw">length</span>(parset.list)) {
    parset =<span class="st"> </span>parset.list[[i]]
    pars =<span class="st"> </span><span class="kw">list</span>(<span class="dt">formula =</span> regr.formula, <span class="dt">data =</span> regr.train)
    pars =<span class="st"> </span><span class="kw">c</span>(pars, parset)
    <span class="kw">set.seed</span>(<span class="kw">getOption</span>(<span class="st">"mlr.debug.seed"</span>))
    m =<span class="st"> </span><span class="kw">do.call</span>(randomForest::randomForest, pars)
    <span class="kw">set.seed</span>(<span class="kw">getOption</span>(<span class="st">"mlr.debug.seed"</span>))
    p =<span class="st"> </span><span class="kw">predict</span>(m, <span class="dt">newdata =</span> regr.test, <span class="dt">type =</span> <span class="st">"response"</span>)
    old.predicts.list[[i]] =<span class="st"> </span>p
  }

  <span class="kw">testSimpleParsets</span>(<span class="st">"regr.randomForest"</span>, regr.df, regr.target,
    regr.train.inds, old.predicts.list, parset.list)
})</code></pre></div>
<p>All tested parameter configurations are collected in the <code>parset.list</code>. In order to make sure that the default parameter configuration is tested the first element of the <code>parset.list</code> is an empty <a href="base::list">list</a>. Then we simply loop over all parameter settings and store the resulting predictions in <code>old.predicts.list</code>. Again the helper function <code>testSimpleParsets</code> does the same using the [%mlr] interface and compares the outcomes.</p>
<p>Additional to tests for individual learners we also have general tests that loop through all integrated learners and make for example sure that learners have the correct properties (e.g. a learner with property <code>"factors"</code> can cope with <a href="base::factor">factor</a> features, a learner with property <code>"weights"</code> takes observation weights into account properly etc.). For example <a href="https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_learners_all_classif.R" class="uri">https://github.com/mlr-org/mlr/blob/master/tests/testthat/test_learners_all_classif.R</a> runs through all classification learners. Similar tests exist for all types of learning methods like regression, cluster and survival analysis as well as multilabel classification.</p>
<p>In order to run all tests for, e.g., classification learners on your machine you can invoke the tests from within <strong>R</strong> by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">devtools::<span class="kw">test</span>(<span class="st">"mlr"</span>, <span class="dt">filter =</span> <span class="st">"classif"</span>)</code></pre></div>
<p>or from the command line using <a href="https://github.com/rdatsci/rt">Michel’s rt tool</a></p>
<pre><code>rtest --filter=classif</code></pre>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#classes-constructors-and-naming-schemes">Classes, constructors, and naming schemes</a></li>
      <li><a href="#classification">Classification</a></li>
      <li><a href="#regression">Regression</a></li>
      <li><a href="#survival-analysis">Survival analysis</a></li>
      <li><a href="#clustering">Clustering</a></li>
      <li><a href="#multilabel-classification">Multilabel classification</a></li>
      <li><a href="#creating-a-new-method-for-extracting-feature-importance-values">Creating a new method for extracting feature importance values</a></li>
      <li><a href="#creating-a-new-method-for-extracting-out-of-bag-predictions">Creating a new method for extracting out-of-bag predictions</a></li>
      <li><a href="#registering-your-learner">Registering your learner</a></li>
      <li><a href="#further-information-for-developers">Further information for developers</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Bernd Bischl, Michel Lang, Lars Kotthoff, Julia Schiffner, Jakob Richter, Zachary Jones, Giuseppe Casalicchio, Mason Gallo.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
